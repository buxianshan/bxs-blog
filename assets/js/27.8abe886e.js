(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{440:function(t,e,r){"use strict";r.r(e);var a=r(36),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),r("p",[t._v("本文参考"),r("a",{attrs:{href:"https://gitbook.cn/gitchat/column/5b26040ac81ac568fcf64ea3",target:"_blank",rel:"noopener noreferrer"}},[t._v("《白话设计模式 28 讲》"),r("OutboundLink")],1),t._v("，感谢作者！")])]),t._v(" "),r("h2",{attrs:{id:"本文简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本文简介"}},[t._v("#")]),t._v(" 本文简介")]),t._v(" "),r("p",[t._v("这是我在学习设计模式的过程中做的一些记录，每一种设计模式尽量使用 Java 和 Python 分别实现样例。")]),t._v(" "),r("h2",{attrs:{id:"什么是设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是设计模式"}},[t._v("#")]),t._v(" 什么是设计模式")]),t._v(" "),r("p",[r("strong",[t._v("设计模式")]),t._v("最初是被 GoF 于 1995 年提出的，GoF（Gang of Four，四人帮）即 Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides。他们四人于 1995 年出版了一本书《Design Patterns：Elements of Reusable Object-Oriented Software》（翻译成中文是《设计模式 可复用面向对象软件的基础》），第一次将设计模式提升到理论高度，并将之规范化，该书提出了 23 种经典的设计模式。")]),t._v(" "),r("p",[t._v("设计模式（Design Pattern）是一套被反复使用、多数人知晓的、无数工程师实践的代码设计经验的总结，它是面向对象思想的高度提炼和模板化，使用设计模式是为了让代码具有更高的可重用性，更好的灵活性和可拓展性，更易被人阅读和理解。GoF 提到的模式有四个基本要素：")]),t._v(" "),r("ul",[r("li",[t._v("模式名称：助记名，方便讨论、交流、传播；")]),t._v(" "),r("li",[t._v("问题：该模式是用来解决哪类实际问题，即它的应用场景；")]),t._v(" "),r("li",[t._v("解决方案：设计的组成部分，它们之间的相互关系及各自的职责和协作方式；")]),t._v(" "),r("li",[t._v("效果：使用模式能达到的效果，即对使用条件的权衡取舍。")])]),t._v(" "),r("h2",{attrs:{id:"设计模式的分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的分类"}},[t._v("#")]),t._v(" 设计模式的分类")]),t._v(" "),r("p",[t._v("参考："),r("a",{attrs:{href:"https://www.runoob.com/design-pattern/design-pattern-intro.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("设计模式的类型"),r("OutboundLink")],1)]),t._v(" "),r("h3",{attrs:{id:"创建型模式-creational-patterns"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式-creational-patterns"}},[t._v("#")]),t._v(" 创建型模式（Creational Patterns）")]),t._v(" "),r("p",[t._v("这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。")]),t._v(" "),r("ul",[r("li",[t._v("工厂模式（Factory Pattern）")]),t._v(" "),r("li",[t._v("抽象工厂模式（Abstract Factory Pattern）")]),t._v(" "),r("li",[t._v("单例模式（Singleton Pattern）")]),t._v(" "),r("li",[t._v("建造者模式（Builder Pattern）")]),t._v(" "),r("li",[t._v("原型模式（Prototype Pattern）")])]),t._v(" "),r("h3",{attrs:{id:"结构型模式-structural-patterns"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式-structural-patterns"}},[t._v("#")]),t._v(" 结构型模式（Structural Patterns）")]),t._v(" "),r("p",[t._v("这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。")]),t._v(" "),r("ul",[r("li",[t._v("适配器模式（Adapter Pattern）")]),t._v(" "),r("li",[t._v("桥接模式（Bridge Pattern）")]),t._v(" "),r("li",[t._v("过滤器模式（Filter、Criteria Pattern）")]),t._v(" "),r("li",[t._v("组合模式（Composite Pattern）")]),t._v(" "),r("li",[t._v("装饰器模式（Decorator Pattern）")]),t._v(" "),r("li",[t._v("外观模式（Facade Pattern）")]),t._v(" "),r("li",[t._v("享元模式（Flyweight Pattern）")]),t._v(" "),r("li",[t._v("代理模式（Proxy Pattern）")])]),t._v(" "),r("h3",{attrs:{id:"行为型模式-behavioral-patterns"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式-behavioral-patterns"}},[t._v("#")]),t._v(" 行为型模式（Behavioral Patterns）")]),t._v(" "),r("p",[t._v("这些设计模式特别关注对象之间的通信。")]),t._v(" "),r("ul",[r("li",[t._v("责任链模式（Chain of Responsibility Pattern）")]),t._v(" "),r("li",[t._v("命令模式（Command Pattern）")]),t._v(" "),r("li",[t._v("解释器模式（Interpreter Pattern）")]),t._v(" "),r("li",[t._v("迭代器模式（Iterator Pattern）")]),t._v(" "),r("li",[t._v("中介者模式（Mediator Pattern）")]),t._v(" "),r("li",[t._v("备忘录模式（Memento Pattern）")]),t._v(" "),r("li",[t._v("观察者模式（Observer Pattern）")]),t._v(" "),r("li",[t._v("状态模式（State Pattern）")]),t._v(" "),r("li",[t._v("空对象模式（Null Object Pattern）")]),t._v(" "),r("li",[t._v("策略模式（Strategy Pattern）")]),t._v(" "),r("li",[t._v("模板模式（Template Pattern）")]),t._v(" "),r("li",[t._v("访问者模式（Visitor Pattern）")])]),t._v(" "),r("h2",{attrs:{id:"六大原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#六大原则"}},[t._v("#")]),t._v(" 六大原则")]),t._v(" "),r("p",[r("strong",[t._v("1、开闭原则（Open Close Principle）")])]),t._v(" "),r("p",[t._v("开闭原则的意思是："),r("strong",[t._v("对扩展开放，对修改关闭")]),t._v("。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。")]),t._v(" "),r("p",[r("strong",[t._v("2、里氏代换原则（Liskov Substitution Principle）")])]),t._v(" "),r("p",[t._v("继承必须确保超类所拥有的性质在子类中仍然成立。")]),t._v(" "),r("p",[r("strong",[t._v("3、依赖倒转原则（Dependence Inversion Principle）")])]),t._v(" "),r("p",[t._v("要面向接口编程，不要面向具体实现编程。")]),t._v(" "),r("p",[r("strong",[t._v("4、接口隔离原则（Interface Segregation Principle）")])]),t._v(" "),r("p",[t._v("这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。")]),t._v(" "),r("p",[r("strong",[t._v("5、迪米特法则，又称最少知道原则（Demeter Principle）")])]),t._v(" "),r("p",[t._v('只与你的直接朋友交谈，不跟"陌生人"说话。一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。')]),t._v(" "),r("p",[r("strong",[t._v("6、合成复用原则（Composite Reuse Principle）")])]),t._v(" "),r("p",[t._v("合成复用原则是指：尽量使用合成/聚合的方式，其次才考虑使用继承关系来实现。")])])}),[],!1,null,null,null);e.default=v.exports}}]);